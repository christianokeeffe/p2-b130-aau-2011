\section{The Development of The Packing Algorithm}
\label{sec:devalgorithm}
The algorithm was developed from the theory described in section \ref{sec:algorithm}. The theory has been extended from the experiences when packing the program. These extensions have made the packing more effective, which results in more items being packed. 
To understand the different methods, the algorithm as described in section \ref{sec:algorithm} must be extended a bit. The extension will be described in this section, with a summing up at the end. To describe the code, this section will be divided in different subsections to understand the different parts of the code.

\subsection{Classes}
To handle the information and functions needed to handle suitcases and items to pack, the classes luggage and luggage\_item have been made. They do both inherit from the class Cube\_Shape, with the variables width, depth, height and name. The Cube\_Shape class provides the information of a cube, which both suitcases and items can be seen as.
\subsubsection{The Class "luggage"}
The class diagram of the luggage class can be seen on Figure \ref{fig:lugclass}. There are a lot of private fields (starting with "\_") which can be accessed through properties. It contains all the values needed: the maximum weight, the weight of the suitcase etc. It also contains a set of methods which is used through the packing process. The properties which should only be accessed in the methods in the class has a private setter, so functions outside the class can only get the value, and not change the properties by a mistake. An example of this is the property "weight", which indicates the total weight of the items in the suitcase and the suitcase' weight. This value should only be set by the class it self in the methods placing an item.

\figur{0.3}{LuggageClass.jpg}{The class diagram of the luggage class}{fig:lugclass}

As seen on Figure \ref{fig:lugclass} there are a set of methods in the class "luggage". These methods provide the necessary functions to handle the suitcase while packing.

\subsubsection{The class "luggage\_item"}
The class luggage\_item is for the items to pack in the luggage. The class diagram can be seen on Figure \ref{fig:lugitemclass}. As in the luggage class, this class has some variables, which can only be accessed through properties. Those properties, which should only be set inside the class have a private setter. There are also a private method "Rotate\_Lug\_Item", which should only be called inside the class.
\figur{0.3}{LuggageItemClass.jpg}{The class diagram of the luggage\_item class}{fig:lugitemclass}
\subsubsection{Using the Classes}
The luggage class and the luggage\_item class is used in the program with a list. These lists of the classes is made by the initialization of the program as seen on Listing \ref{lst:listini}, and is passed through to the other form. These lists contains the information of every suitcase, item and the result of the packing.
\kode{The initialization of the list containing the suitcases and luggages. (From the Main form)}{listini}{ListOfClass.txt}
\subsection{Description of the Code}
The algorithm to pack has been developed from the flowchart seen on figure \ref{fig:flowalgo}. The following will describe the code and the extensions of the flowchart.
\subsubsection{Reset and Sorting}
As seen on the figure, the first thing which is done is to sort the suitcases and the items. Before sorting the lists of suitcases and luggages, it resets the values which were changed when packing. This is to ensure the algorithm has the right values when running it twice. The reset methods for the items and the suitcases are in their respective classes as seen on Figure \ref{fig:lugclass} and Figure \ref{fig:lugitemclass}. A loop will call the reset methods in all suitcases and items in the lists. This is for example to reset the values of where there are saved items in the luggage. The items and luggage is also rotated so the luggage has the longest side as width as seen on Listing \ref{lst:lugrotate}. This is done, so the algorithm packs as optimal as possible. The items is likewise rotated, so the height is the smallest side. This will ensure that the algorithm will try to pack items lying, and not upright.
\kode{The code to rotate the luggage until the longest side is the width. The rotation is made by switching the values of 2 sides. (From the luggage class in the Main form.)}{lugrotate}{RotateLug.txt}
The method to sort the luggages and items will sort them by size, so the largest items will be attempted to be packed first in the biggest suitcases. This will give a better packing, because the smallest items are easier to fit than the big items.
\subsubsection{Weight Distribution}
The average distribution of weight in the luggage is calculated before going in the loop of the packing algorithm. In the flowchart on Figure \ref{fig:flowalgo} it will "Find next suitcase" when packing an item. This is not as simple as shown in the algorithm. The next suitcase is found by not only size, but also weight. It will start with the largest luggage and see if the weight of the suitcase, its content and the item to pack will exceed the average weight per luggage. If it does it will try to use the next luggage. If the item cannot be fitted in any luggage using the average weight, it will try again with only the maximum weight of the luggage in mind, so an item can be packed even though it exceeds the average weight per suitcase. The code of this can be seen on Listing \ref{lst:CheckWeight}, where the stop\_check\_for\_avg\_weight variable checks if there should still be check for average weight. The lug\_id variable is the index in the luggages list of the suitcase which is checked now. The lug\_items\_counter is the index of the item to pack. This loop will continue until the item is packed, or every possibility has been tried.
\kode{The statements checking if the item can be fitted in this luggage by weight. (From the method pack\_items in the Main form)}{CheckWeight}{AvgWeight.txt}
\subsubsection{Checking For Fit in Pivot Points}
If the item could be packed in a suitcase by weight, the algorithm will try to fit the items by weight. The next point is calculated by a sorted list of packing points. The list is sorted so the item is packed at the lowest points first. This is done in the find\_next\_pivot\_point function in the luggage class. If the item placed in the given pivot point without exceeding the dimensions of the suitcase it will call the method in "check\_item\_for\_fit" in the luggage class. This method will run through all the effected point and check if there are placed any items in the points. This method can be seen on Listing \ref{lst:CheckForFit}, where the function will check every point in the array value. This value is an indicator of how many elements which is placed in the point (the value should of course never be higher than one).
\kode{The method to check if the item can be placed at the pivot\_test\_point (from the luggage class in the Main form)}{CheckForFit}{CheckForFit.txt}
If the item cannot be fitted in the point in the luggage, the item will be rotated and tried fitted again. If every rotation possibilities has been tried, it will use the next packing point - or if there are no more packing points, the next suitcase.
\subsubsection{Placing the item}
If the item could not be packed in any suitcase, it will be added to a list of not packed items, which will be printed to the user later on. It will then be removed from the packing list, and the next item will be packed. If the item could be packed, it will try to move it lower in the suitcase until it meets another item in the check\_for\_space\_z in the luggage class. This will ensure an optimal packing. The item will then be packed in the suitcase by adding 1 to the value in every point the item will fill out in the suitcase, using the place\_item method in the luggage class. The packing points is saved to the item, so it have the information of, where it is saved. This is done by the function save\_item from the luggage\_item class. The corners of the item is added to the list of packing points, and the list is sorted. The item is now saved and the next item can be packed.
\subsubsection{When Every Item is Packed}
When all items have been packed (or placed in the list of not packed items), the next step in the algorithm is to generate the colors each item should be displayed with in the 3D Viewer. This code can be seen in section \ref{sec:3DHandler}.
The algorithm will at the end check if there has been a mistake during packing, so one of the values in the luggage has exceeded 1. If it has, it will throw an exception. It will then check, if some of the items could not be packed. This will show an error message to the user, with the information of which elements which could not be packed as seen on Listing \ref{lst:CheckForError}.
\kode{The code will return an error message to the user if some items could not be packed (from the method check\_error\_after\_packing in the form Main)}{CheckForError}{ErrorMessage.txt}

\subsection{Summing up}
The algorithm checks for a lot of different criteria, also a few more than described here. This will ensure a optimal packing of the items, so the highest possible number of item can be fitted in the luggage. Therefore the algorithm has been extended since the first design in section \ref{sec:algorithm}. The extended, but still a bit simplified, flowchart can be seen on Figure \ref{fig:flowexalgo}.

\figur{1}{FlowOfAlgorithmFull.jpg}{The flowchart for the packing algorithm}{fig:flowexalgo}