\section{The Development of The Packing Algorithm}
\label{sec:devalgorithm}
The algorithm was developed from the theory described in section \ref{sec:algorithm}. The theory has been extended from the experiences when packing the program. These extensions have made the packing more effective, which result in that more items can be packed. 
To understand the different methods, the algorithm as described in section \ref{sec:algorithm} must be extended a bit. The extension will be describes in this section, with a roundup at the end. To describe the code, this section will be divided in different subsections to understand the different parts of the code.

\subsection{Classes}
To handle the information and functions needed to handle suitcases and items to pack, the classes luggage and luggage\_item has been made. They do both inherit from the class Cube\_Shape, with the variables width, depth, height and name. The Cube\_Shape class provides the information of a cube, which both suitcases and items can be seen as. It is the dimensions and a name. 
\subsubsection{The class "luggage"}
The class diagram of the luggage class can be seen on Figure \ref{fig:lugclass}. There are a lot of private fields (starting with "\_") which can be accessed through properties. It contains all the values needed: the maximum weight, the weight of the suitcase etc. It contains also a set of methods which is used through the packing process. The properties which should only be accessed in the methods in the class has a private setter, so functions outside the class only can get the value, and not change the properties by a mistake. An example of this is the property "weight", which indicates the total weight of the items in the suitcase and the suitcase' weight. This value should only be set by the class it self in the methods placing an item.

\figur{1}{LuggageClass.jpg}{The class diagram of the luggage class}{fig:lugclass}

As seen on Figure \ref{fig:lugclass} there are a set of methods in the class "luggage". These methods provide the necessary functions to handle the suitcase while packing.

\subsubsection{The class "luggage\_item"}
The class luggage\_item is for the items to pack in the luggage. The class diagram can be seen on Figure \ref{fig:lugitemclass}. As in the luggage class, this class has some variables, which can only be accessed through properties. Those properties, which should only be set inside the class have a private setter. There are also a private method "Rotate\_Lug\_Item", which should only be called inside the class.
\figur{1}{LuggageItemClass.jpg}{The class diagram of the luggage\_item class}{fig:lugitemclass}
\subsubsection{Using the classes}
The luggage class and the luggage\_item class is used in the program with a list. These lists of the classes is made by the initialization of the program as seen on Listing , and is passed thought to the other form. These lists contains the information of every suitcase, item and the result of the packing.
\kode{The initialization of the list containing the suitcases and luggages. (From the Main form)}{listini}{ListOfClass.txt}
\subsection{Description of the code}
The algorithm to pack has been develloped from the flowchart on Figure \ref{fig:flowalgo}. The following will describe the code and the extensions of the flowchart.
\subsubsection{Reset and Sorting}
As seen on the figure, the first thing which is done is to sort the suitcases and the items. Before sorting the suitcases and luggages, it resets the values changes when packing. This is to ensure the algorithm has the right values when running it twice. The reset methods for the items and the suitcases are in their respective classes as seen on Figure \ref{fig:lugclass} and Figure \ref{fig:lugitemclass}. A loop will call the reset methods in all suitcases and items in the lists. This is for example to reset the value of where there are saved items in the luggage. The items and luggage is also rotated so the luggage has the longest side as width as seen on Listing \ref{list:RotateLug}. This is done, so the algoithm packs as optimal as possible. The items is likewise rotated, so the height is the smallest side. This will ensure that the algorithm will try to pack items lying, and not upright.
\kode{The code to rotate the luggage, until the longest side is the width. The rotation is made by switching the values of 2 sides. (From the luggage class in the Main form.)}{lugrotate}{RotateLug.txt}
The method to sort the luggages and items will sort them by size, so the largest items will be attempted to be packed first in the biggest suitcases. This will give a better packing, because the smallest items are easier to fit than the big items.
\subsubsection{Weight Distribution}
The average distribution of weight in the luggage is calculated before going in the loop of the packing algorithm. In the flowchart on Figure \ref{fig:flowalgo} it will "Find next suitcase" when packing a item. This is not as simple as shown in the algorithm. The next suitcase is found by not only size, but also weight. It will start with the largest luggage and see if the weight of the suitcase, its content and the item to pack will exceed the average weight per luggage. If it does it will try to use the next luggages. If the item cannot be fitted in any luggage using the average weight, it will try again with only the maximum weight of the luggage in mind, so a item can be packed even though it exceeds the average weight per suitcase. The code of this can be seen on Listing \ref{list:CheckWeight}, where the stop\_check\_for\_avg\_weight variable checks if there should still be check for average weight. The lug\_id variable if the index in the luggages list of the suitcase which is checked now. The lug\_items\_counter is the index of the item to pack. This loop will continue until the item is packed, or every possibility has been tried.
\kode{The statements checking if the item can be fitted in this luggage by weight.}{CheckWeight}{AvgWeight.txt}
\subsubsection{Checking For Fit in Pivot Points}
If the item could be packed in a suitcase by weight, the algorithm will try to fit the items by weight. 